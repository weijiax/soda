#include "darknet.hpp"

#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/video.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/tracking.hpp>
#include <opencv2/cudabgsegm.hpp>

#include <iostream>

using namespace cv;
using namespace std;
using namespace cv::cuda;

#include <time.h>
#include <stdlib.h>
#include <stdio.h>

#ifndef max(a,b)
#define max(a,b) ( ( (a) > (b) ) ? (a) : (b) )
#endif

#define MAX_OBJ	(512)
#define MAX_POINT	(640)

#define MAX_CAR_SHOW	(32)
#define CAR_WIN_SIZE	(80)

//#define m_minObjectSize_X	(64)
//#define m_minObjectSize_Y	(64)
int m_minObjectSize_X=64, m_minObjectSize_Y=64;

//#define FRAME_to_CONFIRM	(6)
int FRAME_to_CONFIRM=6;

//#define FRAME_to_DEL_OBJ	(10)
int FRAME_to_DEL_OBJ=10;
#define NUM_COLOR	(24)
//#define AREA_RATIO_TO_REMOVE_OBJECT	(0.50)
#define AREA_RATIO_TO_REMOVE_OBJECT	(0.10)
//#define BIG_IOU_OVERLAP	(0.65)
//#define BIG_IOU_OVERLAP	(0.70)
#define BIG_IOU_OVERLAP	(0.75)
#define UNASSIGNED_OBJ	(-1)
#define INVALID_OBJ	(-2)


typedef struct	{
	int x, y, xMax, yMax;
	int type;	// 0 - people;	1 - car or truck;  2- bus
	int prob;
}OBJECT,*POBJECT;

typedef struct	{
	int Used, Confirmed;
	int Idx;	// index starting from 1 !!!!!!!!!
	int Area;
	int Area_Max;
	int vx, vy;
	int x, y, width, height, xMax, yMax;
	int FirstFrame, LastFrame;
	int nNotFounded;	// the number of times NOT detected
	int traj_Pos;
	float nFounded;	// the number of times detected. float point is used. Depend on the overlap with neighbors
	CvPoint trace[MAX_POINT];
	Rect2d boundingBox;
	Mat Img;
	float iou;
	int nPixles;
	int R, G, B;	// dominant color
}TRACKER, *PTRACKER;

void Init_ObjList(void);
int Find_Available_Space(void);
int Query_Object(int x, int y, int width, int height, int IdxStart, float iou_max);	// weight used for nFounded accumulation
int Add_an_Object(int x, int y, int width, int height);
void Remove_an_Object(int idx);
void Update_an_Object(int idx, int x, int y, int width, int height);
void Update_All_Trackers(void);
void Show_Obj_Index(void);
double Get_White_Pixle_Ratio(Mat *pMat, int xMin, int yMin, int width, int height);	// to determine whether this object is in FG or not
void Match_ObjList_and_Yolo_List(void);
void do_Img_Templet_Match(void);
int Is_a_Moving_Object(int idx);
void Merge_Suspicious_Close_Yolo_Objects(void);
void Calculate_IOU_With_Neighbors(void);
void Calculate_IOU_With_Unassigned_Neighbors(void);
void Match_High_Probability_Objects(void);
void Output_Orientation_Data(int i);
void Output_Rest_Orientation_Data(void);
int Is_Moving_Out(int x, int y, int xMax, int yMax, int vx, int vy, int Area_Old, int Area_Cur);
void Find_Car_Pixles(void);


int nObj, nObj_Confirmed=0;
TRACKER ObjList[MAX_OBJ];

int nObj_Yolo=0;
OBJECT Yolo_ObjList[MAX_OBJ];
int Assigned_Yolo_Obj[MAX_OBJ];
int IsMoving[MAX_OBJ];
float iou_Yolo[MAX_OBJ];

int NotFoundObj;
int IsCar[MAX_OBJ];
int FoundObj[MAX_OBJ];
int IdxAvailable;
int Color_List[]={0xd8b2d8, 0x008aa0, 0xac8141, 0x1e90ff, 0x838da6, 0x8b0000, 0xffcccc, 0xe5f2e5, 0xcce5cc, 0xfbe6fb, 
0xffffcc, 0xe5e5ff, 0xffc0cb, 0xf37736, 0xf8d59b, 0x0d6032, 0xc6540d, 0xeb2348, 0x368059, 0x306a9f, 0x67f9f5, 0x8a2be2, 0x66cccc, 0x6dc066};

image im;

Mat img_all;	// the frame combined with car gallery
Mat frame; //current frame
Mat frame_save; //saved copy
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat lt_bg;	// long term background. Cleaner background
Mat fg;	// the mask that indicates car pixles 

int nCarMax;
Mat car_gallery[MAX_CAR_SHOW], car_List;


GpuMat d_frame;
GpuMat d_fgmask;
GpuMat d_lt_bg;
GpuMat d_lt_fgmask;

Ptr<cuda::BackgroundSubtractorMOG2> pMOG2; //MOG2 Background subtractor
Ptr<cuda::BackgroundSubtractorMOG2> pMOG2_lt; //MOG2 Background subtractor with long memory
double Learning_Rate=0.01, Slow_Learning_Rate=0.0002, LT_Learning_Rate=0.01;


double fps, fps_inv, t_video;
int width, height;
int nFrame=0;
char tracker_algorithm[]="KCF";

void Mat_into_image(Mat src, image im);
void Read_Yolo_Detection(FILE *fIn);
void Draw_Car_Gallery(void);

FILE *fVector;

float colors_list[6][3] = { {1,0,1}, {0,0,1},{0,1,1},{0,1,0},{1,1,0},{1,0,0} };
int max_class=80;

void get_object_color(int type, int max_class, unsigned char &red, unsigned char &green, unsigned char &blue)
{
    float ratio = ((float)( (type*123457) % max_class)/max_class)*5.0;
    int i = floor(ratio);
    int j = ceil(ratio);
    ratio -= i;
    
    blue =  (unsigned char) ( ( (1-ratio) * colors_list[i][0] + ratio*colors_list[j][0] ) * 255 );
    green = (unsigned char) ( ( (1-ratio) * colors_list[i][1] + ratio*colors_list[j][1] ) * 255 );
    red =   (unsigned char) ( ( (1-ratio) * colors_list[i][2] + ratio*colors_list[j][2] ) * 255 );
    return;
}

FILE *fOut_nCar, *fOut_nCar_Local;

int main(int argc, char **argv)
{
    float thresh=0.24;
    float hier_thresh=0.50;
    list *options = read_data_cfg("cfg/coco.data");
    char *name_list = option_find_str(options, "names", "data/names.list");
    char **names = get_labels(name_list);
    clock_t time;
    char buff[256], szTxt[128];
    int i,j;
    float nms=.4;
    int keyboard; //input from keyboard
    int ObjIdx;
    int nReadItem, Frame;
    double white_ratio;
    FILE *fOut=NULL, *fIn=NULL;
	unsigned char red, green, blue;
	int dx=0, dy=0;
	int ms_to_sleep, ms_to_sleep_save;
	int nCarYolo, nCarYoloMin=1000, nCarLocal;

	if(argc != 3)	{
		printf("Usage: tracking movie yolo.log\n");
		exit(1);
	}
	
	/*
    image **alphabet = load_alphabet();
    network net = parse_network_cfg("cfg/yolo.cfg");
    load_weights(&net, "/work/00410/huang/maverick/yolo/yolo.weights");
    
	 set_batch_network(&net, 1);
	 layer l = net.layers[net.n-1];
	 srand(2222222);
	 
	  gpu_index = 0;
	  cuda_set_device(gpu_index);
	*/
	
    VideoCapture capture(argv[1]);
    if(!capture.isOpened()){
        //error in opening the video input
        cerr << "Unable to open video file: " << argv[1] << endl;
        exit(EXIT_FAILURE);
    }
    width = capture.get(CV_CAP_PROP_FRAME_WIDTH);
    height = capture.get(CV_CAP_PROP_FRAME_HEIGHT);
    fps = capture.get(CV_CAP_PROP_FPS);
    fps_inv = 1.0/fps;
	ms_to_sleep = (int)(1000.0*0.8/fps);
	ms_to_sleep_save = ms_to_sleep;
    
	m_minObjectSize_X = (int)(height*0.07);
	m_minObjectSize_Y = (int)(height*0.07);
	FRAME_to_CONFIRM = min(max((int)(fps*0.1001), 5), 8);	// at least three frames
	FRAME_to_DEL_OBJ = (int)(fps*0.15);

    nCarMax = (int)(width/CAR_WIN_SIZE);
    img_all = Mat::zeros(Size(width, height+CAR_WIN_SIZE), CV_8UC3);
    car_List = Mat::zeros(Size(width, CAR_WIN_SIZE), CV_8UC3);
    
	fg.create(Size(width, height), CV_8UC1);	// gray

    im = make_image(width, height, 3);	// color image. three channels
    
	pMOG2 = cuda::createBackgroundSubtractorMOG2(2400);
	pMOG2_lt = cuda::createBackgroundSubtractorMOG2(3600);

	fOut_nCar = fopen("out_ncar.txt", "w");
	fOut_nCar_Local = fopen("out_ncar_Local.txt", "w");
    
    fOut = fopen("out.log", "w");
    fIn = fopen(argv[2], "r");
    if(fIn == NULL)	{
		printf("Fail to open file: %s for Yolo detection records.\nExit\n", argv[2]);
    }
	fVector=fopen("out_vector.txt", "w");
	
	//		VideoWriter video("out.mov", CV_FOURCC('H','2','6','4'), fps, Size(width,height), true);
	VideoWriter video("out.mov", CV_FOURCC('H','2','6','4'), fps, Size(width,height+CAR_WIN_SIZE), true);
	
    while( (char)keyboard != 'q' && (char)keyboard != 27 ){
        //read the current frame
        if(!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
			break;
        }
        frame.copyTo(frame_save);
        nFrame++;
        
        t_video += fps_inv;
		
        time=clock();
        
        if(nFrame == 1)	{
			d_frame.create(frame.size(), frame.type());
			d_lt_bg.create(frame.size(), frame.type());
        }
        d_frame.upload(frame);
        pMOG2->apply(d_frame, d_fgmask, Learning_Rate);
		d_fgmask.download(fgMaskMOG2);

		sprintf(szTxt, "%5d", nFrame);
        putText(frame, szTxt, cv::Point( 48, 48), FONT_HERSHEY_SIMPLEX, 2.0 , cv::Scalar(0,255,0));;
		
		/*
        Mat_into_image(frame, im);
        image sized = letterbox_image(im, net.w, net.h);
		
		 box *boxes = (box *)calloc(l.w*l.h*l.n, sizeof(box));
		 float **probs = (float **)calloc(l.w*l.h*l.n, sizeof(float *));
		 for(j = 0; j < l.w*l.h*l.n; ++j) probs[j] = (float *)calloc(l.classes + 1, sizeof(float *));
		 
		  float *X = sized.data;
		  network_predict(net, X);
		  get_region_boxes(l, im.w, im.h, net.w, net.h, thresh, probs, boxes, 0, 0, hier_thresh, 1);
		  if (nms) do_nms_obj(boxes, probs, l.w*l.h*l.n, l.classes, nms);
		  //else if (nms) do_nms_sort(boxes, probs, l.w*l.h*l.n, l.classes, nms);
		  
		   draw_detections_Ex(im, l.w*l.h*l.n, thresh, boxes, probs, names, alphabet, l.classes, &nObj_Yolo, (int*)Yolo_ObjList);
		*/
        Read_Yolo_Detection(fIn);

		nCarYolo = 0;
        memset(FoundObj, 0, sizeof(int)*MAX_OBJ);
        for(i=0; i<nObj_Yolo; i++) {
			if( (Yolo_ObjList[i].type == 28) && ( ( (Yolo_ObjList[i].xMax-Yolo_ObjList[i].x) > 40) && ((Yolo_ObjList[i].yMax-Yolo_ObjList[i].y) > 40) ) )	{	// suitcase. Should be a car
				Yolo_ObjList[i].type = 2;	// car
			}

			Assigned_Yolo_Obj[i] = UNASSIGNED_OBJ;
			IsMoving[i] = Is_a_Moving_Object(i);

			if( (Yolo_ObjList[i].type == 2) || (Yolo_ObjList[i].type == 5) || (Yolo_ObjList[i].type == 7) )	{
				IsCar[i] = 1;
				nCarYolo++;
			}
			else	{
				IsCar[i] = 0;
			}
		}

		if(nCarYoloMin > nCarYolo)	nCarYoloMin = nCarYolo;
        LT_Learning_Rate = 0.05 * 1.0/(1+10.0*pow(nCarYolo-nCarYoloMin, 4.0));
        if( (nCarYolo-nCarYoloMin) < 5 )	pMOG2_lt->apply(d_frame, d_lt_fgmask, LT_Learning_Rate);
		pMOG2_lt->getBackgroundImage(d_lt_bg);
		if (!d_lt_bg.empty())	{
			d_lt_bg.download(lt_bg);
//			imshow("BG", lt_bg);
			if(nFrame % 500==0)	{
				imwrite("out_bg.jpg", lt_bg);
			}
		}

		if(nFrame == 29)	{
			printf("DBG> ");
		}

		Calculate_IOU_With_Neighbors();
		Match_High_Probability_Objects();
		Merge_Suspicious_Close_Yolo_Objects();

        for(i=0; i<nObj_Yolo; i++) {
			if( ( (1.0*(Yolo_ObjList[i].xMax-Yolo_ObjList[i].x)/width) > 0.4) || ( (1.0*(Yolo_ObjList[i].xMax-Yolo_ObjList[i].x)/width) > 0.4) )	{
				continue;
			}
			//				sprintf(szTxt, "%4.2lf", (double)(Yolo_ObjList[i].prob/100.0) );
			//				putText(frame, szTxt, cv::Point( (Yolo_ObjList[i].x+Yolo_ObjList[i].xMax)/2-8, (Yolo_ObjList[i].y+Yolo_ObjList[i].yMax)/2-8), FONT_HERSHEY_SIMPLEX, 1.0 , cv::Scalar(0,255,0));;
			get_object_color(Yolo_ObjList[i].type, max_class, red, green, blue);
			if(IsMoving[i])	{
				rectangle(frame, Point(Yolo_ObjList[i].x, Yolo_ObjList[i].y), Point(Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax), Scalar(blue,green,red), 7, 8, 0 );
//				rectangle(frame, Point(Yolo_ObjList[i].x, Yolo_ObjList[i].y), Point(Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax), Scalar(blue,green,red), 1, 8, 0 );
			}
			else	{
				rectangle(frame, Point(Yolo_ObjList[i].x, Yolo_ObjList[i].y), Point(Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax), Scalar(blue,green,red), 1, 8, 0 );
			}
						
			if( IsCar[i] && (Assigned_Yolo_Obj[i] == UNASSIGNED_OBJ) )	{	// car, truck or bus. Person is not included.
				//							rectangle(frame, Point(Yolo_ObjList[i].x, Yolo_ObjList[i].y), Point(Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax), Scalar(0,0,255), 1, 8, 0 );  		
//				white_ratio = Get_White_Pixle_Ratio(&fgMaskMOG2, Yolo_ObjList[i].x, Yolo_ObjList[i].y, Yolo_ObjList[i].xMax - Yolo_ObjList[i].x, Yolo_ObjList[i].yMax-Yolo_ObjList[i].y);
				//        			sprintf(szTxt, "%4.2lf", white_ratio);
				//			        putText(frame, szTxt, cv::Point( (Yolo_ObjList[i].x+Yolo_ObjList[i].xMax)/2-8, (Yolo_ObjList[i].y+Yolo_ObjList[i].yMax)/2-8), FONT_HERSHEY_SIMPLEX, 1.0 , cv::Scalar(0,255,0));;
				//           	  if( (white_ratio > 0.15) && (Yolo_ObjList[i].prob > 0.55*100) && ( (Yolo_ObjList[i].xMax-Yolo_ObjList[i].x) > m_minObjectSize_X) && ( (Yolo_ObjList[i].yMax-Yolo_ObjList[i].y) > m_minObjectSize_Y) ) {
				//           	  if( (white_ratio > 0.15) && (Yolo_ObjList[i].prob > 0.60*100) && ( (Yolo_ObjList[i].xMax-Yolo_ObjList[i].x) > m_minObjectSize_X) && ( (Yolo_ObjList[i].yMax-Yolo_ObjList[i].y) > m_minObjectSize_Y) ) {	// handle high quality object first. Possible new objects?
//				if( (white_ratio > 0.18) && (Yolo_ObjList[i].prob > 0.60*100) && ( (Yolo_ObjList[i].xMax-Yolo_ObjList[i].x) > m_minObjectSize_X) && ( (Yolo_ObjList[i].yMax-Yolo_ObjList[i].y) > m_minObjectSize_Y) ) {	// handle high quality object first. Possible new objects?
				if( IsMoving[i] && (Yolo_ObjList[i].prob > 0.60*100) && ( (Yolo_ObjList[i].xMax-Yolo_ObjList[i].x) > m_minObjectSize_X) && ( (Yolo_ObjList[i].yMax-Yolo_ObjList[i].y) > m_minObjectSize_Y) ) {	// handle high quality object first. Possible new objects?
					//           	  if( (white_ratio > 0.15) && (Yolo_ObjList[i].prob > 0.60*100) && ( (Yolo_ObjList[i].xMax-Yolo_ObjList[i].x) > m_minObjectSize_X) && ( (Yolo_ObjList[i].yMax-Yolo_ObjList[i].y) > m_minObjectSize_Y) ) {	// handle high quality object first. Possible new objects?
					ObjIdx = Query_Object(Yolo_ObjList[i].x, Yolo_ObjList[i].y, Yolo_ObjList[i].xMax - Yolo_ObjList[i].x, Yolo_ObjList[i].yMax-Yolo_ObjList[i].y, 0, iou_Yolo[i]);
					
					if(ObjIdx < 0)	{	// Not exist
						printf("Add an object (%d, %d, %d, %d)\n", Yolo_ObjList[i].x, Yolo_ObjList[i].y, Yolo_ObjList[i].xMax - Yolo_ObjList[i].x, Yolo_ObjList[i].yMax-Yolo_ObjList[i].y);
						ObjIdx = Add_an_Object(Yolo_ObjList[i].x, Yolo_ObjList[i].y, Yolo_ObjList[i].xMax - Yolo_ObjList[i].x, Yolo_ObjList[i].yMax-Yolo_ObjList[i].y);
					}
					else	{
						Update_an_Object(ObjIdx, Yolo_ObjList[i].x, Yolo_ObjList[i].y, Yolo_ObjList[i].xMax - Yolo_ObjList[i].x, Yolo_ObjList[i].yMax-Yolo_ObjList[i].y);
					}
					FoundObj[ObjIdx] = 1;
					Assigned_Yolo_Obj[i] = ObjIdx;
				}
			}
			
        }
        
        NotFoundObj=0;
		Calculate_IOU_With_Unassigned_Neighbors();
        Match_ObjList_and_Yolo_List();
        do_Img_Templet_Match();

//		Find_Car_Pixles();

        Show_Obj_Index();

		nCarLocal = 0;

        if(nFrame < 3)	{
			for(i=0; i<nObj_Yolo; i++) {
				fprintf(fOut, "%5d, %5d, %5d, %5d, %2d, %2d, %4d, %4d, %4d, %4d, %4d, %4d\n", 
					nFrame, i+1, -1, -1, Yolo_ObjList[i].type, Yolo_ObjList[i].prob, Yolo_ObjList[i].x, Yolo_ObjList[i].y, 
					Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax, 0, 0);
			}
		}
		else	{
			for(i=0; i<nObj_Yolo; i++) {
				// 1. frame index
				// 2. object index in yolo detection list
				// 3. moving or not	(-1 = Unknown)
				// 4. car index	( -1 = Unknown )
				// 5. object type (yolo, coco.name)
				// 6. probablity*100 (int)
				// 7. xMin
				// 8. yMin
				// 9. xMax
				//10. yMax
				//11. dx (position displacement compared with several frames ago in x direction)
				//12. dy (position displacement compared with several frames ago in y direction)
				if(Assigned_Yolo_Obj[i] > UNASSIGNED_OBJ)	{	// assigned object
					nCarLocal++;
					ObjIdx = Assigned_Yolo_Obj[i];
					if( ObjList[ObjIdx].traj_Pos > 1)	{
						dx = ObjList[ObjIdx].trace[ObjList[ObjIdx].traj_Pos-1].x - ObjList[ObjIdx].trace[ObjList[ObjIdx].traj_Pos-2].x;
						dy = ObjList[ObjIdx].trace[ObjList[ObjIdx].traj_Pos-1].y - ObjList[ObjIdx].trace[ObjList[ObjIdx].traj_Pos-2].y;
						fprintf(fOut, "%5d, %5d, %5d, %5d, %2d, %2d, %4d, %4d, %4d, %4d, %4d, %4d\n", 
							nFrame, i+1, IsMoving[i], ObjList[ObjIdx].Idx, Yolo_ObjList[i].type, Yolo_ObjList[i].prob, Yolo_ObjList[i].x, Yolo_ObjList[i].y, 
							Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax, dx, dy);
					}
					else	{	// only one record saved
						fprintf(fOut, "%5d, %5d, %5d, %5d, %2d, %2d, %4d, %4d, %4d, %4d, %4d, %4d\n", 
							nFrame, i+1, IsMoving[i], ObjList[ObjIdx].Idx, Yolo_ObjList[i].type, Yolo_ObjList[i].prob, Yolo_ObjList[i].x, Yolo_ObjList[i].y, 
							Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax, 0, 0);
					}
				}
				else	{
					fprintf(fOut, "%5d, %5d, %5d, %5d, %2d, %2d, %4d, %4d, %4d, %4d, %4d, %4d\n", 
						nFrame, i+1, -1, -1, Yolo_ObjList[i].type, Yolo_ObjList[i].prob, Yolo_ObjList[i].x, Yolo_ObjList[i].y, 
						Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax, 0, 0);
				}
			}
		}
		
		
		/*
        free_image(sized);
        free(boxes);
        free_ptrs((void **)probs, l.w*l.h*l.n);
		*/
		
		frame.copyTo( img_all( Rect(0, 0, width, height) ) );
        Draw_Car_Gallery();
		//        imshow("Detection", img_all);
        
		//        imshow("FG", fgMaskMOG2);
		//        keyboard=waitKey(35);
		//			imshow("Detection", frame);

		
//		imshow("Detection", img_all);
//		keyboard=waitKey(ms_to_sleep);


//		if(nFrame > 2100)	keyboard=waitKey(0);
//		else	keyboard=waitKey(5);
//		if(nFrame > 435)	keyboard=waitKey(0);
//		else	keyboard=waitKey(5);
//		keyboard=waitKey(15);
		
//		keyboard=waitKey(0);
		/*
        if(nFrame > 1550)	{
		keyboard=waitKey(0);
		}
		else	{
		keyboard=waitKey(20);
		}
		*/
		//        if(NotFoundObj > 0)	keyboard=waitKey(0);
		video.write(img_all);
//		if(nFrame > 8000)	{
			//				if(nFrame > 1600)	{
//			break;
//		}
		
        if(keyboard == 'p') waitKey(0);
        if(keyboard == 's') ms_to_sleep=0;
        if(keyboard == 'n') ms_to_sleep=ms_to_sleep_save;

		fprintf(fOut_nCar, "%6d %d\n", nFrame, nObj_Confirmed);	// the number of cars identified
		fprintf(fOut_nCar_Local, "%6d %d\n", nFrame, nCarLocal);	// the number of cars identified
    }
    capture.release();
	
	
    if(fOut) fclose(fOut);
    if(fIn)	fclose(fIn);

	fclose(fOut_nCar);
	fclose(fOut_nCar_Local);

	Output_Rest_Orientation_Data();
    if(fVector)	fclose(fVector);
	
	//    save_image(im, "output");
	//    imshow("MyWindow", img);
	//    waitKey(0);
	
    free_image(im);
	
    return 0;
}

void Read_Yolo_Detection(FILE *fIn)
{
	int Frame_Yolo;
	int i, nReadItem, nObjUsed=0, WidthMax, HeightMax;
	
	WidthMax = (int)(0.5 * width);	// apply size filter to exclude too large objects. Most likely errors in Yolo
	HeightMax = (int)(0.6 * height);

	nReadItem = fscanf(fIn, "%d%d", &Frame_Yolo, &nObj_Yolo);
	if(nReadItem != 2)	{
		printf("Error in reading Yolo detection record.\nExit\n");
		fclose(fIn);
		exit(1);
	}
	if(Frame_Yolo != nFrame)	{
		printf("Error in reading Yolo detection record.\nFrame_Yolo != nFrame\n");
		fclose(fIn);
		exit(1);
	}
	
	for(i=0; i<nObj_Yolo; i++)	{
		nReadItem = fscanf(fIn, "%d%d%d%d%d%d", 
			&(Yolo_ObjList[nObjUsed].type), &(Yolo_ObjList[nObjUsed].x), &(Yolo_ObjList[nObjUsed].y), &(Yolo_ObjList[nObjUsed].xMax), &(Yolo_ObjList[nObjUsed].yMax), &(Yolo_ObjList[nObjUsed].prob) );
		if(nReadItem != 6)	{
			printf("Error in reading Yolo detection record. Frame = %d\nExit\n", Frame_Yolo);
			fclose(fIn);
			exit(1);
		}
		if( ( (Yolo_ObjList[nObjUsed].xMax - Yolo_ObjList[nObjUsed].x) < WidthMax ) && ( (Yolo_ObjList[nObjUsed].yMax - Yolo_ObjList[nObjUsed].y) < HeightMax ) )	nObjUsed++;
	}

	nObj_Yolo = nObjUsed;	// The too large objects are removed already. Correct the number of objects.
}


void Mat_into_image(Mat src, image im)
{
    unsigned char *data = (unsigned char *)(src.data);
    int h = src.rows;
    int w = src.cols;
    int c = src.channels();
    int step = src.step;
    int i, j, k, w_h, w_h_2;
    
    w_h = w * h;
    w_h_2 = w_h*2;
	
    for(i = 0; i < h; ++i){
        for(j = 0; j < w; ++j){
            for(k= 0; k < c; ++k){
                im.data[k*w*h + i*w + j] = data[i*step + j*c + k]/255.;	// convert to float
            }
        }
    }
	
    k = 0;	// Red
    for(i = 0; i < h; ++i){
        for(j = 0; j < w; ++j){
			im.data[i*w + j] = data[i*step + j*c + 2]/255.;	// convert to float
        }
    }
	
    k = 1;	// Green
    for(i = 0; i < h; ++i){
        for(j = 0; j < w; ++j){
			im.data[w_h + i*w + j] = data[i*step + j*c + 1]/255.;	// convert to float
        }
    }
	
    k = 2;	// Blue
    for(i = 0; i < h; ++i){
        for(j = 0; j < w; ++j){
			im.data[w_h_2 + i*w + j] = data[i*step + j*c    ]/255.;	// convert to float
        }
    }
	//    rgbgr_image(out);	// swap R<->B
}


void Init_ObjList(void)
{
	int i;
	
	nObj = 0;
	
	for(i=0; i<MAX_OBJ; i++)	{
		ObjList[i].Used = 0;
		ObjList[i].Confirmed = 0;
		ObjList[i].Idx = -1;
		ObjList[i].nNotFounded = 0;
		ObjList[i].traj_Pos = 0;
		//		ObjList[i].tracker = NULL;
	}
	
	IdxAvailable = 0;
}

void Remove_an_Object(int idx)
{
	if(ObjList[idx].Confirmed)	Output_Orientation_Data(idx);

	ObjList[idx].Used = 0;
	ObjList[idx].Confirmed = 0;
	ObjList[idx].Idx = -1;
	ObjList[idx].traj_Pos = 0;
	ObjList[idx].Img.~Mat();
}

int Find_Available_Space(void)
{
	int i;
	
	for(i=0; i<MAX_OBJ; i++)	{
		if(ObjList[i].Used == 0)	{
			return i;
		}
	}
	printf("Fail to find an available space for a new object!\n");
	exit(1);
	return -1;
}

#define DIST_RATIO	(0.18)
int Query_Object(int x, int y, int width, int height, int IdxStart, float iou_max)	// to avoid smaller subset or big overlap
{
	int i, area_a, area_b;
	float iou;
	box box_a, box_b;
	PTRACKER pTracker;
	int xc, yc, xc_2, yc_2, dist_SQ, dist_SQ_CUT;
	
	box_a.x = x;
	box_a.y = y;
	box_a.w = width;
	box_a.h = height;
	
	xc = (int)(x + 0.5*width);
	yc = (int)(y + 0.5*height);
	
	area_a = width*height;
////	dist_SQ_CUT = (int)(*DIST_RATIO);
	for(i=IdxStart; i<MAX_OBJ; i++)	{
		if(ObjList[i].Confirmed)	{
			pTracker = &(ObjList[i]);
			
			box_b.x = pTracker->x + pTracker->vx;
			box_b.y = pTracker->y + pTracker->vy;
			box_b.w = pTracker->width;
			box_b.h = pTracker->height;
			
			iou = box_iou(box_a, box_b);
			if(iou > BIG_IOU_OVERLAP)	{	// large overlap. The same object?
				pTracker->LastFrame = nFrame;
				pTracker->nFounded += ( max(0, (1.0 - iou_max*1.6) ) );	// depends on iou now!
				pTracker->nNotFounded = 0;
				return i;
			}

			area_b = pTracker->width * pTracker->height;
			dist_SQ_CUT = DIST_RATIO * sqrt(area_a*area_b);
			
			xc_2 = (int)( (pTracker->x + pTracker->xMax)/2 + pTracker->vx);
			yc_2 = (int)( (pTracker->y + pTracker->yMax)/2 + pTracker->vy);
			dist_SQ = (xc-xc_2)*(xc-xc_2) + (yc-yc_2)*(yc-yc_2);
			if(dist_SQ < dist_SQ_CUT)	{	// the centers are so close. 
				pTracker->nNotFounded = 0;
				return i;
			}
		}
	}
	
	for(i=IdxStart; i<MAX_OBJ; i++)	{
		if(ObjList[i].Used && (ObjList[i].Confirmed==0) )	{
			pTracker = &(ObjList[i]);
			
			box_b.x = pTracker->x + pTracker->vx;
			box_b.y = pTracker->y + pTracker->vy;
			box_b.w = pTracker->width;
			box_b.h = pTracker->height;
			
			iou = box_iou(box_a, box_b);
			if(iou > BIG_IOU_OVERLAP)	{	// large overlap. The same object?
				pTracker->LastFrame = nFrame;
//				pTracker->nFounded++;
				pTracker->nFounded += ( max(0, (1.0 - iou_max*1.6) ) );	// depends on iou now!

				if(pTracker->nFounded > FRAME_to_CONFIRM)	{
					if(pTracker->Confirmed == 0)	{
						if(Is_Moving_Out(pTracker->x, pTracker->y, pTracker->xMax, pTracker->yMax, pTracker->vx, pTracker->vy, pTracker->Area, pTracker->width*pTracker->height) )	{
							Remove_an_Object(i);
							continue;
						}

						nObj_Confirmed++;
						pTracker->Idx = nObj_Confirmed;
						
						// Add into car gallery
						int width_new, height_new, x_new, y_new;
						Mat car=Mat(frame_save, Rect(x, y, width, height));
						if(width > height)	{
							width_new = CAR_WIN_SIZE;
							height_new = (int)(1.0*CAR_WIN_SIZE*height/width);
							x_new = 0;
							y_new = (width_new-height_new)/2;
						}
						else	{
							height_new = CAR_WIN_SIZE;
							width_new = (int)(1.0*CAR_WIN_SIZE*width/height);
							x_new = (height_new-width_new)/2;
							y_new = 0;
						}
						if(! car_gallery[(nObj_Confirmed-1)%nCarMax].empty())	{
							car_gallery[(nObj_Confirmed-1)%nCarMax].~Mat();
						}
						car_gallery[(nObj_Confirmed-1)%nCarMax] = Mat::zeros(Size(CAR_WIN_SIZE, CAR_WIN_SIZE), frame.type());
						Mat icon;
						resize(car, icon, Size(width_new, height_new));//resize image
						icon.copyTo( car_gallery[(nObj_Confirmed-1)%nCarMax]( Rect(x_new, y_new, width_new, height_new) ) );

						pTracker->trace[0].x = (int)(x + 0.5*width);
						pTracker->trace[0].y = (int)(y + 0.5*height);
						pTracker->traj_Pos = 1;
						pTracker->Confirmed = 1;
					}
				}
				pTracker->nNotFounded = 0;
				return i;
			}
			
			area_b = pTracker->width * pTracker->height;
			dist_SQ_CUT = DIST_RATIO * sqrt(area_a*area_b);

			xc_2 = (int)( (pTracker->x + pTracker->xMax)/2 + pTracker->vx);
			yc_2 = (int)( (pTracker->y + pTracker->yMax)/2 + pTracker->vy);
			dist_SQ = (xc-xc_2)*(xc-xc_2) + (yc-yc_2)*(yc-yc_2);
			if(dist_SQ < dist_SQ_CUT)	{	// the centers are so close. 
				pTracker->nNotFounded = 0;
				return i;
			}
		
		}
	}
	


	return (-1);
}

int Find_Closest_Yolo_Object(int x, int y, int xMax, int yMax)
{
	int i;
	int xc, yc, xc_2, yc_2, dist_SQ, dist_SQ_Min=100000, idx=-1;
	
	xc = (x+xMax)/2;
	yc = (y+yMax)/2;
	
	for(i=0; i<nObj_Yolo; i++) {
		if(IsCar[i] > 0)	{	// car, truck or bus. Person is not included.
			xc_2 = (Yolo_ObjList[i].x + Yolo_ObjList[i].xMax)/2;
			yc_2 = (Yolo_ObjList[i].y + Yolo_ObjList[i].yMax)/2;
			
			dist_SQ = (xc-xc_2)*(xc-xc_2) + (yc-yc_2)*(yc-yc_2);
			if(dist_SQ < dist_SQ_Min)	{
				dist_SQ_Min = dist_SQ;
				idx = i;
			}
		}
	}
	return idx;
}

#define MIN_L_WIDENED (48)
//#define L_WIDENED	(128)	// defines search range
void do_Img_Templet_Match(void)
{
	int i, idx;
	PTRACKER pTracker;
	
#pragma omp parallel for private(i, pTracker) schedule(static,1)
	for(i=0; i<MAX_OBJ; i++)	{
		//	if(ObjList[i].Used && (FoundObj[i] == 0) )	{
		if(ObjList[i].Confirmed && (FoundObj[i] == 0) )	{
			int x, y, xMax, yMax;
			char szTxt[64];

			pTracker = &(ObjList[i]);
//			idx = Find_Closest_Yolo_Object(pTracker->x, pTracker->y, pTracker->xMax, pTracker->yMax);
			idx = Find_Closest_Yolo_Object(pTracker->x+pTracker->vx, pTracker->y+pTracker->vy, pTracker->xMax+pTracker->vx, pTracker->yMax+pTracker->vy);
///////			rectangle(frame, Point(Yolo_ObjList[idx].x, Yolo_ObjList[idx].y), Point(Yolo_ObjList[idx].xMax, Yolo_ObjList[idx].yMax), Scalar(0,255,0), 1, 8, 0 );
//			printf("Unfound obje: %d, (%d, %d, %d, %d)\n", i, );
///////			rectangle(frame, Point(pTracker->x+pTracker->vx, pTracker->y+pTracker->vy), Point(pTracker->xMax+pTracker->vx, pTracker->yMax+pTracker->vy), Scalar(0,0,255), 1, 8, 0 );
			
			x = max(0, pTracker->x + pTracker->vx - max(MIN_L_WIDENED, abs((int)(1.5*pTracker->vx))) );
			xMax = min(frame.cols-1, pTracker->xMax + pTracker->vx + max(MIN_L_WIDENED, abs((int)(1.5*pTracker->vx))) );
			y = max(0, pTracker->y + pTracker->vy - max(MIN_L_WIDENED, abs((int)(1.5*pTracker->vy))) );
			yMax = min(frame.rows-1, pTracker->yMax + pTracker->vy + max(MIN_L_WIDENED, abs((int)(1.5*pTracker->vy))) );
			Mat result;
			Mat search=Mat(frame_save, Rect(x, y, xMax-x, yMax-y));
			
			//			printf("Info of big image: %d %d %d\n", search.depth(), search.type(), search.dims);
			//			printf("Info of small image: %d %d %d\n", pTracker->Img.depth(), pTracker->Img.type(), pTracker->Img.dims);
			//			if(pTracker->Img.dims == 0)	{
			//				printf("Wrong object: %d\n", i);
			//			}
			
			matchTemplate( search, pTracker->Img, result, CV_TM_SQDIFF_NORMED);
			//      matchTemplate( search, pTracker->Img, result, CV_TM_CCOEFF_NORMED);
			//      matchTemplate( search, pTracker->Img, result, CV_TM_CCOEFF);
			//      matchTemplate( search, pTracker->Img, result, CV_TM_CCORR);
			//      normalize( result, result, 0, 1, NORM_MINMAX, -1, Mat() );
			double minVal; double maxVal; Point minLoc; Point maxLoc;
			Point matchLoc;
			minMaxLoc( result, &minVal, &maxVal, &minLoc, &maxLoc, Mat() );
			matchLoc = minLoc;
			printf("Box(%d,%d,%d,%d) Found at (%d,%d) minVal = %7.5lf\n", 
				pTracker->x, pTracker->y, pTracker->xMax, pTracker->yMax, matchLoc.x+x, matchLoc.y+y, minVal);
			rectangle(frame, Point(matchLoc.x+x, matchLoc.y+y), Point( matchLoc.x + x + pTracker->Img.cols , matchLoc.y + y + pTracker->Img.rows ), Scalar(0,0,255), 2, 8, 0 );

//			rectangle(search, Point(matchLoc.x, matchLoc.y), Point( matchLoc.x + pTracker->Img.cols , matchLoc.y + pTracker->Img.rows ), Scalar(255,0,0), 2, 8, 0 );
//			imshow("Big", search);
//			imshow("Small", pTracker->Img);
			

			int x_new, y_new;
//			x_new = (int)( 0.5*pTracker->x + 0.5*(matchLoc.x+x) );
//			y_new = (int)( 0.5*pTracker->y + 0.5*(matchLoc.y+y) );
			x_new = matchLoc.x+x;
			y_new = matchLoc.y+y;
			//      if(maxVal > 0.8) Update_an_Object(i, matchLoc.x+x, matchLoc.y+y, pTracker->width, pTracker->height);
			if(minVal < 0.006)	{	// NEED YOLO obj to confirm!!!!!!!!!!!!!!!!!!!
				// 			sprintf(szTxt, "%7.5lf", minVal);
				//      putText(frame, szTxt, cv::Point( matchLoc.x+x-16, matchLoc.x+y-16), FONT_HERSHEY_SIMPLEX, 1.0 , cv::Scalar(0,255,0));;
//				FoundObj[i] = 1;
				Update_an_Object(i, x_new, y_new, pTracker->width, pTracker->height);
//				Update_an_Object(i, matchLoc.x+x, matchLoc.y+y, pTracker->width, pTracker->height);
				//			imshow("Search", pTracker->Img);
				//      rectangle(frame, Point(matchLoc.x+x, matchLoc.y+y), Point( matchLoc.x + x + pTracker->Img.cols , matchLoc.y + y + pTracker->Img.rows ), Scalar(0,255,255), 2, 8, 0 );	// yellow
				//			imshow("Found", frame);
				//			waitKey(0);
			}
		}
	}
}

void Match_ObjList_and_Yolo_List(void)
{
	int i, j, xc, yc, dist_SQ, dist_SQ_Min, xc_2, yc_2, Found, ObjIdx, Dist_SQ_CUT, idx_dist_Save, idx_iou_Save, idx_Assign;
	PTRACKER pTracker;
	float iou, iou_max=0.0;
	box box_a, box_b;
	
	for(j=0; j<MAX_OBJ; j++)	{	// confirmed object has higher priority
		if(ObjList[j].Confirmed && (FoundObj[j] == 0))	{	// not assigned yet

			pTracker = &(ObjList[j]);
			// 			xc_2 = pTracker->boundingBox.x + 0.5*pTracker->boundingBox.width + pTracker->vx;
			// 			yc_2 = pTracker->boundingBox.y + 0.5*pTracker->boundingBox.height + pTracker->vy;
			xc_2 = pTracker->x + 0.5*pTracker->width + pTracker->vx;
			yc_2 = pTracker->y + 0.5*pTracker->height + pTracker->vy;
			
			box_a.x = pTracker->x + pTracker->vx;
			box_a.y = pTracker->y + pTracker->vy;
			box_a.w = pTracker->width;
			box_a.h = pTracker->height;
			
			Found = 0;
			dist_SQ_Min = 100000;	// initialization with a large enough value
//			Dist_SQ_CUT = (int)(pTracker->width*pTracker->height*0.25);	// !!!!!!!!!!!!!!!!!!!
			Dist_SQ_CUT = (int)(pTracker->width*pTracker->height*0.18);	// !!!!!!!!!!!!!!!!!!!
			for(i=0; i<nObj_Yolo; i++)	{
				if( IsCar[i] && (Assigned_Yolo_Obj[i]==UNASSIGNED_OBJ) )	{	// car, truck or bus. Person is not included.
					box_b.x = Yolo_ObjList[i].x;
					box_b.y = Yolo_ObjList[i].y;
					box_b.w = Yolo_ObjList[i].xMax-Yolo_ObjList[i].x;
					box_b.h = Yolo_ObjList[i].yMax-Yolo_ObjList[i].y;
					
					iou = box_iou(box_a, box_b);
					if(iou > iou_max)	{
						iou_max = iou;
						idx_iou_Save = i;
					}
					
					xc = (Yolo_ObjList[i].x + Yolo_ObjList[i].xMax)/2;
					yc = (Yolo_ObjList[i].y + Yolo_ObjList[i].yMax)/2;
					dist_SQ = (xc-xc_2)*(xc-xc_2) + (yc-yc_2)*(yc-yc_2);
					if(dist_SQ < dist_SQ_Min)	{
						idx_dist_Save = i;
						dist_SQ_Min = dist_SQ;
					}
				}
			}
			
			if(ObjList[j].iou < 0.25)	{	// low overlap with neighbored unassigned objects. Looser condition will be applied
				if(iou_max > (BIG_IOU_OVERLAP*0.55) )	{
					FoundObj[j] = 1;
					idx_Assign = idx_iou_Save;
				}
				else if(dist_SQ_Min < (int)(Dist_SQ_CUT*1.2) )	{
					FoundObj[j] = 1;
					idx_Assign = idx_dist_Save;
				}
			}
			else	{	// tighter condition applied
				if(iou_max > BIG_IOU_OVERLAP)	{
					FoundObj[j] = 1;
					idx_Assign = idx_iou_Save;
				}
				else if(dist_SQ_Min < Dist_SQ_CUT)	{
					FoundObj[j] = 1;
					idx_Assign = idx_dist_Save;
				}
			}

			if(FoundObj[j])	{	// a cutoff
				Assigned_Yolo_Obj[idx_Assign] = j;
				Update_an_Object(j, Yolo_ObjList[idx_Assign].x, Yolo_ObjList[idx_Assign].y, Yolo_ObjList[idx_Assign].xMax - Yolo_ObjList[idx_Assign].x, Yolo_ObjList[idx_Assign].yMax-Yolo_ObjList[idx_Assign].y);
			}
			else	{
				// 				rectangle(frame, Point(pTracker->x, pTracker->y), Point(pTracker->xMax+pTracker->vx, pTracker->yMax+pTracker->vy), Scalar(0, 0, 255), 3, 8, 0 );
				if(pTracker->Confirmed)	{
					printf("Fail to find object %d: (%d, %d, %d, %d)\n", pTracker->Idx, pTracker->x + pTracker->vx, pTracker->y + pTracker->vy, pTracker->xMax + pTracker->vx, pTracker->yMax + pTracker->vy);
///////					rectangle(frame, Point(pTracker->x + pTracker->vx, pTracker->y + pTracker->vy), Point(pTracker->xMax + pTracker->vx, pTracker->yMax + pTracker->vy), Scalar(0,0,255), 1, 8, 0 );
				}
				NotFoundObj++;
			}
		}
	}
	

	for(j=0; j<MAX_OBJ; j++)	{
		if(ObjList[j].Used && (ObjList[j].Confirmed==0) && (FoundObj[j] == 0))	{	// not assigned yet

			pTracker = &(ObjList[j]);
			// 			xc_2 = pTracker->boundingBox.x + 0.5*pTracker->boundingBox.width + pTracker->vx;
			// 			yc_2 = pTracker->boundingBox.y + 0.5*pTracker->boundingBox.height + pTracker->vy;
			xc_2 = pTracker->x + 0.5*pTracker->width + pTracker->vx;
			yc_2 = pTracker->y + 0.5*pTracker->height + pTracker->vy;
			
			box_a.x = pTracker->x + pTracker->vx;
			box_a.y = pTracker->y + pTracker->vy;
			box_a.w = pTracker->width;
			box_a.h = pTracker->height;
			
			Found = 0;
			dist_SQ_Min = 100000;	// initialization with a large enough value
//			Dist_SQ_CUT = (int)(pTracker->width*pTracker->height*0.25);	// !!!!!!!!!!!!!!!!!!!
			Dist_SQ_CUT = (int)(pTracker->width*pTracker->height*0.18);	// !!!!!!!!!!!!!!!!!!!
			for(i=0; i<nObj_Yolo; i++)	{
				if( IsCar[i] && (Assigned_Yolo_Obj[i]==UNASSIGNED_OBJ) )	{	// car, truck or bus. Person is not included.
					box_b.x = Yolo_ObjList[i].x;
					box_b.y = Yolo_ObjList[i].y;
					box_b.w = Yolo_ObjList[i].xMax-Yolo_ObjList[i].x;
					box_b.h = Yolo_ObjList[i].yMax-Yolo_ObjList[i].y;
					
					iou = box_iou(box_a, box_b);
					if(iou > iou_max)	{
						iou_max = iou;
						idx_iou_Save = i;
					}
					
					xc = (Yolo_ObjList[i].x + Yolo_ObjList[i].xMax)/2;
					yc = (Yolo_ObjList[i].y + Yolo_ObjList[i].yMax)/2;
					dist_SQ = (xc-xc_2)*(xc-xc_2) + (yc-yc_2)*(yc-yc_2);
					if(dist_SQ < dist_SQ_Min)	{
						idx_dist_Save = i;
						dist_SQ_Min = dist_SQ;
					}
				}
			}
			
			if(ObjList[j].iou < 0.25)	{	// low overlap with neighbored unassigned objects. Looser condition will be applied
				if(iou_max > (BIG_IOU_OVERLAP*0.55) )	{
					FoundObj[j] = 1;
					idx_Assign = idx_iou_Save;
				}
				else if(dist_SQ_Min < (int)(Dist_SQ_CUT*1.2) )	{
					FoundObj[j] = 1;
					idx_Assign = idx_dist_Save;
				}
			}
			else	{	// tighter condition applied
				if(iou_max > BIG_IOU_OVERLAP)	{
					FoundObj[j] = 1;
					idx_Assign = idx_iou_Save;
				}
				else if(dist_SQ_Min < Dist_SQ_CUT)	{
					FoundObj[j] = 1;
					idx_Assign = idx_dist_Save;
				}
			}

			if(FoundObj[j])	{	// a cutoff
				Assigned_Yolo_Obj[idx_Assign] = j;
				Update_an_Object(j, Yolo_ObjList[idx_Assign].x, Yolo_ObjList[idx_Assign].y, Yolo_ObjList[idx_Assign].xMax - Yolo_ObjList[idx_Assign].x, Yolo_ObjList[idx_Assign].yMax-Yolo_ObjList[idx_Assign].y);
			}
			else	{
				// 				rectangle(frame, Point(pTracker->x, pTracker->y), Point(pTracker->xMax+pTracker->vx, pTracker->yMax+pTracker->vy), Scalar(0, 0, 255), 3, 8, 0 );
				if(pTracker->Confirmed)	{
					printf("Fail to find object %d: (%d, %d, %d, %d)\n", pTracker->Idx, pTracker->x + pTracker->vx, pTracker->y + pTracker->vy, pTracker->xMax + pTracker->vx, pTracker->yMax + pTracker->vy);
//					rectangle(frame, Point(pTracker->x + pTracker->vx, pTracker->y + pTracker->vy), Point(pTracker->xMax + pTracker->vx, pTracker->yMax + pTracker->vy), Scalar(0,0,255), 1, 8, 0 );
				}
				NotFoundObj++;
			}
		}
	}


	printf("nFrame = %5d  NotFoundObj = %d\n", nFrame, NotFoundObj);
}


int Add_an_Object(int x, int y, int width, int height)
{
	PTRACKER pTracker;
	
	IdxAvailable = Find_Available_Space();
	
	pTracker = &(ObjList[IdxAvailable]);
	
	pTracker->x = x;
	pTracker->y = y;
	pTracker->width = width;
	pTracker->height = height;
	pTracker->xMax = x + width;
	pTracker->yMax = y + height;
	
	pTracker->Area_Max = width*height;
	
	//	pTracker->trace[0].x = (int)(x + 0.5*width);
	//	pTracker->trace[0].y = (int)(y + 0.5*height);
	
	pTracker->vx = 0;
	pTracker->vy = 0;
	
	pTracker->Area = width*height;
	
	pTracker->boundingBox.x = (int)(x+0.25*width);	// only trace the center part
	pTracker->boundingBox.y = (int)(y+0.25*height);
	pTracker->boundingBox.width = (int)(0.5*width);
	pTracker->boundingBox.height = (int)(0.5*height);
	
	nObj++;
	pTracker->Used = 1;
	
//	pTracker->trace[pTracker->traj_Pos].x = (int)(x + 0.5*width);
//	pTracker->trace[pTracker->traj_Pos].y = (int)(y + 0.5*height);
//	pTracker->traj_Pos = 1;
	
	pTracker->FirstFrame=nFrame;
	pTracker->Confirmed=0;
	pTracker->nFounded = 1;
	pTracker->nNotFounded = 0;
	
	if(! pTracker->Img.empty())	{
		pTracker->Img.~Mat();
	}
	pTracker->Img = Mat(frame_save, Rect(x,y,width,height));
	
	return IdxAvailable;
}

//#define BUFF_L	(6)
#define BUFF_L	(22)
int Is_Moving_Out(int x, int y, int xMax, int yMax, int vx, int vy, int Area_Old, int Area_Cur)
{
	if( ( (x - BUFF_L) < 0 ) && ( (vx < 0) || (Area_Cur < Area_Old) ) )	{
		return 1;
	}
	else if( ( (xMax + BUFF_L) > width ) && ( (vx > 0) || (Area_Cur < Area_Old) ) )	{
		return 1;
	}
	else if( ( (y - BUFF_L) < 0 ) && ( (vy < 0) || (Area_Cur < Area_Old) ) )	{
		return 1;
	}
	else if( ( (yMax + BUFF_L) > height ) && ( (vy > 0) || (Area_Cur < Area_Old) ) )	{
		return 1;
	}
	return 0;
}

void Update_an_Object(int idx, int x, int y, int width, int height)
{
	PTRACKER pTracker;
	int Area, Area_Old, x_new, y_new;
	float dx, dy, dArea_ratio;
	
	pTracker = &(ObjList[idx]);
	
	dx = (x + 0.5*width) - (pTracker->x + 0.5*pTracker->width);
	dy = (y + 0.5*height) - (pTracker->y + 0.5*pTracker->height);
	
	pTracker->vx = (int)(pTracker->vx*0.75 + dx*0.25);
	pTracker->vy = (int)(pTracker->vy*0.75 + dy*0.25);
	
	pTracker->x = x;
	pTracker->y = y;
	pTracker->width = width;
	pTracker->height = height;
	pTracker->xMax = x + width;
	pTracker->yMax = y + height;
	
	if(! pTracker->Img.empty())	{
		pTracker->Img.~Mat();
	}
	pTracker->Img = Mat(frame_save, Rect(x,y,width,height));
	
	Area_Old = pTracker->Area;
	Area = width * height;
	dArea_ratio = fabs(1.0 - 1.0*Area/Area_Old);
	if( dArea_ratio > 0.05 )	{	// Update the saved area only big enough change is found to suppress noise.
		pTracker->Area = Area;
	}

	if( (Area < pTracker->Area) && ( (width < (int)(m_minObjectSize_X*1.05) ) || ( height < (int)(m_minObjectSize_Y*1.05) ) ) )	{	// if the area is decreasing, do not add the object
//	if( ( width < (int)(m_minObjectSize_X*0.95) ) || ( height < (int)(m_minObjectSize_Y*0.95) ) )	{	// if the area is decreasing, do not add the object
		pTracker->nFounded--;
	}
	
	if( Area > pTracker->Area_Max  )	{
		pTracker->Area_Max = Area;
		if(pTracker->Confirmed)	{
			// Add into car gallery
			int width_new, height_new, x_new, y_new;
			Mat car=Mat(frame_save, Rect(x, y, width, height));
			if(width > height)	{
				width_new = CAR_WIN_SIZE;
				height_new = (int)(1.0*CAR_WIN_SIZE*height/width);
				x_new = 0;
				y_new = (width_new-height_new)/2;
			}
			else	{
				height_new = CAR_WIN_SIZE;
				width_new = (int)(1.0*CAR_WIN_SIZE*width/height);
				x_new = (height_new-width_new)/2;
				y_new = 0;
			}

			if( (nObj_Confirmed - pTracker->Idx) < nCarMax )	{	// Only limited cars will be shown.
				if(! car_gallery[(pTracker->Idx-1)%nCarMax].empty())	{
					car_gallery[(pTracker->Idx-1)%nCarMax].~Mat();
				}
				car_gallery[(pTracker->Idx-1)%nCarMax] = Mat::zeros(Size(CAR_WIN_SIZE, CAR_WIN_SIZE), frame.type());
				Mat icon;
				resize(car, icon, Size(width_new, height_new));//resize image
				icon.copyTo( car_gallery[(pTracker->Idx-1)%nCarMax]( Rect(x_new, y_new, width_new, height_new) ) );
			}
		}
	}
	else if( Is_Moving_Out(pTracker->x, pTracker->y, pTracker->xMax, pTracker->yMax, pTracker->vx, pTracker->vy, Area_Old, pTracker->Area) )	{
		Remove_an_Object(idx);
		return;
	}
//	else if( ( (1.0*Area/pTracker->Area_Max) < AREA_RATIO_TO_REMOVE_OBJECT ) || ( width < (int)(m_minObjectSize_X*0.8) ) || (height < (int)(m_minObjectSize_Y*0.8) ) )	{	// becoming smaller. Treated as NOT found
	else if( ( (1.0*Area/pTracker->Area_Max) < AREA_RATIO_TO_REMOVE_OBJECT ) || ( width < (int)(m_minObjectSize_X*0.8) ) || (height < (int)(m_minObjectSize_Y*0.8) ) )	{	// becoming smaller. Treated as NOT found
		printf("Removing car: %d\n", ObjList[idx].Idx);
		printf("        info: Size(%d,%d) idx = %d  label = %d\n", width, height, idx, ObjList[idx].Idx);
		//		pTracker->nNotFounded += 1;
		pTracker->nNotFounded = FRAME_to_DEL_OBJ + 1;	// Remove the object
		Remove_an_Object(idx);
		return;
	}
	
	if(pTracker->Confirmed)	{
		x_new = (int)(x + 0.5*width);
		y_new = (int)(y + 0.5*height);
		dx = x_new - pTracker->trace[pTracker->traj_Pos-1].x;
		dy = y_new - pTracker->trace[pTracker->traj_Pos-1].y;
		if( (dx*dx + dy*dy) > 500 )	{	// move long enough distance
			pTracker->trace[pTracker->traj_Pos].x = x_new;
			pTracker->trace[pTracker->traj_Pos].y = y_new;
			pTracker->traj_Pos++;
		}
	}
	
}

void Show_Obj_Index(void)
{
	int i, x, y;
	char szTxt[64];
	
	for(i=0; i<MAX_OBJ; i++)	{
		if(FoundObj[i] == 0)	{
			ObjList[i].nNotFounded++;
			if( (ObjList[i].nNotFounded > FRAME_to_DEL_OBJ) && ObjList[i].Confirmed )	{
				Remove_an_Object(i);
			}
		}
		
		if(ObjList[i].Confirmed)	{
		    printf("Car info: Size(%d,%d) idx = %d  label = %d\n", ObjList[i].width, ObjList[i].height, i, ObjList[i].Idx);
			x = (int)(ObjList[i].x + 0.5*ObjList[i].width) - 16;
			y = (int)(ObjList[i].y + 0.5*ObjList[i].height) + 6;
			sprintf(szTxt, "%d", ObjList[i].Idx);
			
			putText(frame, szTxt, cv::Point(x, y), FONT_HERSHEY_TRIPLEX, 1.5 , cv::Scalar(0,255,0));;
			//			putText(frame, szTxt, cv::Point(x, y), FONT_HERSHEY_SIMPLEX, 1.5 , cv::Scalar(0,255,0));;
			////////			rectangle(frame, Point(ObjList[i].x, ObjList[i].y), Point( ObjList[i].x+ObjList[i].width, ObjList[i].y+ObjList[i].height), Scalar(255, 0, 0), 3, 8, 0 );
		}
	}
	
}


double Get_White_Pixle_Ratio(Mat *pMat, int xMin, int yMin, int width, int height)
{
	int Sum=0;
	int x, y, xMax, yMax, step;
	uchar *ptr;
	double ratio;
	
	xMax = xMin + width;
	yMax = yMin + height;
	step = pMat->step;
	
	for(y=yMin; y<yMax; y++)        {
		ptr = pMat->data + y*step;
		for(x=xMin; x<xMax; x++)        {
			Sum += ptr[x];
		}
	}
	
	ratio = 1.0*Sum/(255*width*height);
	
	return ratio;
}

void Draw_Car_Gallery(void)
{
	int nCar_to_Show, idx, idx_wrapped, count=0;
	char szTxt[64];
	
	nCar_to_Show = min(nCarMax, nObj_Confirmed);
	idx = (nObj_Confirmed - 1);
	idx_wrapped = (idx + nCarMax)%nCarMax;
	while(count < nCar_to_Show)	{
		car_gallery[idx_wrapped].copyTo( car_List( Rect(idx_wrapped*CAR_WIN_SIZE, 0, CAR_WIN_SIZE, CAR_WIN_SIZE) ) );
		sprintf(szTxt, "%d", idx+1);	// car index
		putText(car_List, szTxt, cv::Point(idx_wrapped*CAR_WIN_SIZE+12, 28), FONT_HERSHEY_SIMPLEX, 1.1 , cv::Scalar(0,255,0));
		if(count == 0)	rectangle(car_List, Point(idx_wrapped*CAR_WIN_SIZE+2, 2), Point( (idx_wrapped+1)*CAR_WIN_SIZE-4, CAR_WIN_SIZE-2), Scalar(0, 0, 255), 3, 8, 0 );
		count++;
		idx--;
		idx_wrapped = (idx + nCarMax)%nCarMax;
	}
	car_List.copyTo( img_all( Rect(0, height, width, CAR_WIN_SIZE) ) );
}

#define RATIO_CHECK	(0.6)
#define DIFF_RGB_SQ_CUT	(4000.0)
int Is_a_Moving_Object(int idx)
{
	double white_ratio;
	int x, y, width, height, xMin, xMax, yMin, yMax, idx_Old, iPos, dR, dG, dB;
	char szTxt[128];
	
	xMin = 0.5*(Yolo_ObjList[idx].x + Yolo_ObjList[idx].xMax) - RATIO_CHECK*0.5*(Yolo_ObjList[idx].xMax - Yolo_ObjList[idx].x);
	xMax = 0.5*(Yolo_ObjList[idx].x + Yolo_ObjList[idx].xMax) + RATIO_CHECK*0.5*(Yolo_ObjList[idx].xMax - Yolo_ObjList[idx].x);
	
	yMin = 0.5*(Yolo_ObjList[idx].y + Yolo_ObjList[idx].yMax) - RATIO_CHECK*0.5*(Yolo_ObjList[idx].yMax - Yolo_ObjList[idx].y);
	yMax = 0.5*(Yolo_ObjList[idx].y + Yolo_ObjList[idx].yMax) + RATIO_CHECK*0.5*(Yolo_ObjList[idx].yMax - Yolo_ObjList[idx].y);
	
	//	white_ratio = Get_White_Pixle_Ratio(&fgMaskMOG2, Yolo_ObjList[idx].x, Yolo_ObjList[idx].y, Yolo_ObjList[idx].xMax - Yolo_ObjList[idx].x, Yolo_ObjList[idx].yMax-Yolo_ObjList[idx].y);
	white_ratio = Get_White_Pixle_Ratio(&fgMaskMOG2, xMin, yMin, xMax - xMin, yMax - yMin);
	//	sprintf(szTxt, "%4.2lf", white_ratio);
	//	putText(frame, szTxt, cv::Point( (Yolo_ObjList[idx].x+Yolo_ObjList[idx].xMax)/2-8, (Yolo_ObjList[idx].y+Yolo_ObjList[idx].yMax)/2-8), FONT_HERSHEY_SIMPLEX, 1.0 , cv::Scalar(0,255,0));;
	
//	if( white_ratio > 0.15)	{
	if( white_ratio > 0.18)	{
		return 1;
	}
	else	{
		return 0;
	}
}

void Calculate_IOU_With_Unassigned_Neighbors(void)
{
	int i, j;
	float iou;
	box box_a, box_b;

	for(i=0; i<MAX_OBJ; i++)	{
		if( ObjList[i].Confirmed && (FoundObj[i]==0) )	{	// re-calculate IOU between non-assigned objects
			ObjList[i].iou = 0.0;
		}
	}

	for(i=0; i<MAX_OBJ; i++)	{
		if(ObjList[i].Confirmed && (FoundObj[i]==0) )	{
			box_a.x = ObjList[i].x;
			box_a.y = ObjList[i].y;
			box_a.w = ObjList[i].xMax - ObjList[i].x;
			box_a.h = ObjList[i].yMax - ObjList[i].y;

			for(j=0; j<MAX_OBJ; j++)	{
				if(j==i)	continue;	// itself, then skip!

				if(ObjList[j].Confirmed && (FoundObj[j]==0) )	{
					box_b.x = ObjList[j].x;
					box_b.y = ObjList[j].y;
					box_b.w = ObjList[j].xMax - ObjList[j].x;
					box_b.h = ObjList[j].yMax - ObjList[j].y;
					
					iou = box_iou(box_a, box_b);
					if(iou > ObjList[i].iou)	{
						ObjList[i].iou = iou;
					}
					if(iou > ObjList[j].iou)	{
						ObjList[j].iou = iou;
					}
				}
			}

		}
	}

}

void Calculate_IOU_With_Neighbors(void)
{
	int i, j;
	float iou;
	box box_a, box_b;

	for(i=0; i<MAX_OBJ; i++)	{
		if(ObjList[i].Used)	{
			ObjList[i].iou = 0.0;
		}
	}

	for(i=0; i<MAX_OBJ; i++)	{
//		if(ObjList[i].Confirmed)	{
		if(ObjList[i].Used)	{
			box_a.x = ObjList[i].x;
			box_a.y = ObjList[i].y;
			box_a.w = ObjList[i].xMax - ObjList[i].x;
			box_a.h = ObjList[i].yMax - ObjList[i].y;

			for(j=0; j<MAX_OBJ; j++)	{
				if(j==i)	continue;	// itself, then skip!

				if(ObjList[j].Confirmed)	{
					box_b.x = ObjList[j].x;
					box_b.y = ObjList[j].y;
					box_b.w = ObjList[j].xMax - ObjList[j].x;
					box_b.h = ObjList[j].yMax - ObjList[j].y;
					
					iou = box_iou(box_a, box_b);
					if(iou > ObjList[i].iou)	{
						ObjList[i].iou = iou;
					}
					if(iou > ObjList[j].iou)	{
						ObjList[j].iou = iou;
					}
				}
			}

		}
	}

}


#define PERFECT_MATCH_IOU	(0.85)
void Match_High_Probability_Objects(void)
{
	int i, j, IdxObj;
	PTRACKER pObj;
	box box_a, box_c;
	float iou;

	for(i=0; i<nObj_Yolo; i++)	{
		if( (Assigned_Yolo_Obj[i] > UNASSIGNED_OBJ) || (IsCar[i]==0) )	continue;
		box_a.x = Yolo_ObjList[i].x;
		box_a.y = Yolo_ObjList[i].y;
		box_a.w = Yolo_ObjList[i].xMax - Yolo_ObjList[i].x;
		box_a.h = Yolo_ObjList[i].yMax - Yolo_ObjList[i].y;

		for(j=0; j<MAX_OBJ; j++)	{
			if(ObjList[j].Confirmed)	{
				pObj = &(ObjList[j]);
				box_c.x = pObj->x + pObj->vx;
				box_c.y = pObj->y + pObj->vy;
				box_c.w = pObj->width;
				box_c.h = pObj->height;

				iou = box_iou(box_a, box_c);
				if( (iou >= PERFECT_MATCH_IOU) || (  (ObjList[j].iou < 0.25) && (iou >= (PERFECT_MATCH_IOU*0.85)) ) )	{
					IdxObj = Query_Object(Yolo_ObjList[i].x, Yolo_ObjList[i].y, Yolo_ObjList[i].xMax - Yolo_ObjList[i].x, Yolo_ObjList[i].yMax - Yolo_ObjList[i].y, j, 0.0);	// start from the newly found object
					if(IdxObj == j)	{	// expected !!!
						Assigned_Yolo_Obj[i] = IdxObj;
						Update_an_Object(IdxObj, Yolo_ObjList[i].x, Yolo_ObjList[i].y, Yolo_ObjList[i].xMax - Yolo_ObjList[i].x, Yolo_ObjList[i].yMax - Yolo_ObjList[i].y);
						FoundObj[IdxObj] = 1;
//						rectangle(frame, Point(Yolo_ObjList[i].x, Yolo_ObjList[i].y), Point( Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax), Scalar(0, 255, 0), 6, 8, 0 );	// show the new box for debugging
					}
					else	{
						printf("Possible error in Match_High_Probability_Objects().\n");
					}
					break;
				}
			}
		}
	}
}

#define OVERLAP_CHECK	(0.05)
//#define OVERLAP_CHECK	(0.20)
#define OVERLAP_IN_BOX	(0.60)
#define IOU_SAME_BOX	(0.57)
void Merge_Suspicious_Close_Yolo_Objects(void)
{
	int i, j, k, IdxObj, nHighOverlap;
	float area_a, area_b, area_intersection, ratio, ratio_a, ratio_b, iou, iou_max;
	box box_a, box_b, box_c, box_ab;
	PTRACKER pObj;
	int xNew, yNew, xMaxNew, yMaxNew;	// merge two boxes' coordinates
	
/*
	for(i=0; i<nObj_Yolo; i++)	{
		nHighOverlap = 0;

		if( (Assigned_Yolo_Obj[i] > UNASSIGNED_OBJ) || (IsCar[i] == 0) )	continue;
		box_a.x = Yolo_ObjList[i].x;
		box_a.y = Yolo_ObjList[i].y;
		box_a.w = Yolo_ObjList[i].xMax - Yolo_ObjList[i].x;
		box_a.h = Yolo_ObjList[i].yMax - Yolo_ObjList[i].y;
		area_a = box_a.w*box_a.h;

		for(j=0; j<nObj_Yolo; j++)	{
			if(j==i)	break;
			if( (Assigned_Yolo_Obj[j] > UNASSIGNED_OBJ) || (IsCar[j] == 0) )	continue;
			box_b.x = Yolo_ObjList[j].x;
			box_b.y = Yolo_ObjList[j].y;
			box_b.w = Yolo_ObjList[j].xMax - Yolo_ObjList[j].x;
			box_b.h = Yolo_ObjList[j].yMax - Yolo_ObjList[j].y;
			if( ( box_intersection(box_a, box_b)/area_a ) > 0.40 )	{
				nHighOverlap++;
				if(nHighOverlap >= 2)	{
					Assigned_Yolo_Obj[i] = INVALID_OBJ;
				}
			}
		}

	}
*/

	for(i=0; i<nObj_Yolo; i++)	{
		IdxObj = -1;
		if( (Assigned_Yolo_Obj[i] > UNASSIGNED_OBJ) || (IsCar[i] == 0) )	continue;
		box_a.x = Yolo_ObjList[i].x;
		box_a.y = Yolo_ObjList[i].y;
		box_a.w = Yolo_ObjList[i].xMax - Yolo_ObjList[i].x;
		box_a.h = Yolo_ObjList[i].yMax - Yolo_ObjList[i].y;
		area_a = box_a.w * box_a.h;
		
		for(j=0; j<nObj_Yolo; j++)	{
			if(j==i)	continue;
//			if( Assigned_Yolo_Obj[i] > UNASSIGNED_OBJ )	break;	// the status of box_a is modified !!!
//			if( (Assigned_Yolo_Obj[j] > UNASSIGNED_OBJ) || (IsCar[j] == 0) )	continue;
			if( IsCar[j] == 0 )	continue;
			box_b.x = Yolo_ObjList[j].x;
			box_b.y = Yolo_ObjList[j].y;
			box_b.w = Yolo_ObjList[j].xMax - Yolo_ObjList[j].x;
			box_b.h = Yolo_ObjList[j].yMax - Yolo_ObjList[j].y;
			area_b = box_b.w * box_b.h;
			
			area_intersection = box_intersection(box_a, box_b);
			ratio = area_intersection / min(area_a, area_b);
			
			if(ratio > OVERLAP_CHECK)	{
				xNew = min(Yolo_ObjList[i].x, Yolo_ObjList[j].x);
				yNew = min(Yolo_ObjList[i].y, Yolo_ObjList[j].y);
				xMaxNew = max(Yolo_ObjList[i].xMax, Yolo_ObjList[j].xMax);
				yMaxNew = max(Yolo_ObjList[i].yMax, Yolo_ObjList[j].yMax);

				box_ab.x = xNew;
				box_ab.y = yNew;
				box_ab.w = xMaxNew - xNew;
				box_ab.h = yMaxNew - yNew;

				printf("DBG> box a (%d,%d)  box b (%d,%d)  box ab (%d,%d)\n", (int)box_a.w, (int)box_a.h, (int)box_b.w, (int)box_b.h, (int)box_ab.w, (int)box_ab.h);

///////				rectangle(frame, Point(Yolo_ObjList[i].x, Yolo_ObjList[i].y), Point( Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax), Scalar(0, 0, 255), 2, 8, 0 );
///////				rectangle(frame, Point(Yolo_ObjList[j].x, Yolo_ObjList[j].y), Point( Yolo_ObjList[j].xMax, Yolo_ObjList[j].yMax), Scalar(0, 255, 0), 2, 8, 0 );

//				printf("Box %d and %d are close.\n", i, j);
				for(k=0; k<MAX_OBJ; k++)	{
					if(ObjList[k].Confirmed)	printf("DBG> car %d, iou = %4.2lf\n", ObjList[k].Idx, ObjList[k].iou);
					if(ObjList[k].Confirmed && (ObjList[k].iou < 0.1) )	{	// strong requirement
						pObj = &(ObjList[k]);
						box_c.x = pObj->x + pObj->vx;
						box_c.y = pObj->y + pObj->vy;
						box_c.w = pObj->width;
						box_c.h = pObj->height;

						iou = box_iou(box_ab, box_c);
						printf("DBG> iou = %4.3lf idx = %d\n", iou, ObjList[k].Idx);
//						area_intersection = box_intersection(box_a, box_c);
//						ratio_a = area_intersection / area_a;
//						area_intersection = box_intersection(box_b, box_c);
//						ratio_b = area_intersection / area_b;

//						if( (ratio_a > OVERLAP_IN_BOX) && (ratio_b > OVERLAP_IN_BOX) )	{	// the real object box contains both box_a and box_b
						if( iou > IOU_SAME_BOX )	{	// the real object box contains both box_a and box_b
							printf("Found object %d for box %d and %d.\n", k, i, j);
							// Further do templet matching to make sure that labeled object does include
							xNew = max( min( xNew,  pObj->x + pObj->vx ), 0 );	// Must >= 0
							yNew = max( min( yNew,  pObj->y + pObj->vy ), 0 );
							xMaxNew = min( max( xMaxNew, pObj->xMax), width - 1);
							yMaxNew = min( max( yMaxNew, pObj->yMax), height - 1 );
////////							rectangle(frame, Point(xNew, yNew), Point( xMaxNew, yMaxNew), Scalar(255, 0, 0), 6, 8, 0 );	// show the new box for debugging

							if(Assigned_Yolo_Obj[j] > UNASSIGNED_OBJ)	{	// assigned already
								IdxObj = -1;
								Assigned_Yolo_Obj[i] = INVALID_OBJ;	// Redundant object, removed this object. 

								Yolo_ObjList[i].x = Yolo_ObjList[j].x;	// update coordinate too.
								Yolo_ObjList[i].y = Yolo_ObjList[j].y;
								Yolo_ObjList[i].xMax = Yolo_ObjList[j].xMax;
								Yolo_ObjList[i].yMax = Yolo_ObjList[j].yMax;
								area_a = (Yolo_ObjList[i].xMax - Yolo_ObjList[i].x) * (Yolo_ObjList[i].yMax - Yolo_ObjList[i].y);
							}
							else	{
								IdxObj = k;

								Assigned_Yolo_Obj[j] = INVALID_OBJ;	// Redundant object, removed this object. 
								Yolo_ObjList[j].x = xNew;
								Yolo_ObjList[j].y = yNew;
								Yolo_ObjList[j].xMax = xMaxNew;
								Yolo_ObjList[j].yMax = yMaxNew;

								Yolo_ObjList[i].x = xNew;	// update coordinate too.
								Yolo_ObjList[i].y = yNew;
								Yolo_ObjList[i].xMax = xMaxNew;
								Yolo_ObjList[i].yMax = yMaxNew;
								area_a = (xMaxNew - xNew) * (yMaxNew - yNew);
							}

							break;
						}
					}
				}
			}
			
			//  		rectangle(frame, Point(Yolo_ObjList[i].x, Yolo_ObjList[i].y), Point( Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax), Scalar(255, 0, 0), 2, 8, 0 );
			//  		rectangle(frame, Point(Yolo_ObjList[j].x, Yolo_ObjList[j].y), Point( Yolo_ObjList[j].xMax, Yolo_ObjList[j].yMax), Scalar(255, 0, 0), 2, 8, 0 );
		}

		if( (IdxObj >= 0) && (Assigned_Yolo_Obj[i]==UNASSIGNED_OBJ) )	{
			k = IdxObj;	// save a copy
			IdxObj = Query_Object(Yolo_ObjList[i].x, Yolo_ObjList[i].y, Yolo_ObjList[i].xMax - Yolo_ObjList[i].x, Yolo_ObjList[i].yMax - Yolo_ObjList[i].y, k, 0.0);	// start from the newly found object. iou is not calculated yet.
			if(IdxObj == k)	{	// expected !!!
				Assigned_Yolo_Obj[i] = IdxObj;
				Update_an_Object(IdxObj, Yolo_ObjList[i].x, Yolo_ObjList[i].y, Yolo_ObjList[i].xMax - Yolo_ObjList[i].x, Yolo_ObjList[i].yMax - Yolo_ObjList[i].y);
				FoundObj[IdxObj] = 1;
				
				rectangle(frame, Point(Yolo_ObjList[i].x, Yolo_ObjList[i].y), Point( Yolo_ObjList[i].xMax, Yolo_ObjList[i].yMax), Scalar(0, 0, 255), 6, 8, 0 );	// show the new box for debugging
			}
			else	{
				printf("Possible error in merging two close boxes.\n");
			}
		}
	}

	for(i=0; i<nObj_Yolo; i++)	{
		if( IsCar[i] )	iou_Yolo[i] = 0.0;
	}
	
	for(i=0; i<nObj_Yolo; i++)	{
		if( IsCar[i] == 0 )	continue;
		box_a.x = Yolo_ObjList[i].x;
		box_a.y = Yolo_ObjList[i].y;
		box_a.w = Yolo_ObjList[i].xMax - Yolo_ObjList[i].x;
		box_a.h = Yolo_ObjList[i].yMax - Yolo_ObjList[i].y;		

		for(j=i+1; j<nObj_Yolo; j++)	{
			if( IsCar[j] == 0 )	continue;
			box_b.x = Yolo_ObjList[j].x;
			box_b.y = Yolo_ObjList[j].y;
			box_b.w = Yolo_ObjList[j].xMax - Yolo_ObjList[j].x;
			box_b.h = Yolo_ObjList[j].yMax - Yolo_ObjList[j].y;

			iou = box_iou(box_a, box_b);
			if(iou > iou_Yolo[i])	{
				iou_Yolo[i] = iou;
			}
			if(iou > iou_Yolo[j])	{
				iou_Yolo[j] = iou;
			}
		}
	}
}

// pixle check is needed to make sure two redudant objects have similar color!

void Output_Orientation_Data(int i)
{
	float dx_1, dy_1, dx_2, dy_2, p_dot, p_cross, p_dot_abs, r_inv;
	char szDirection[][12]={"straight", "left", "right", "U turn"};
	int Direction;


	if(ObjList[i].traj_Pos > 2)	{
		dx_1 = ObjList[i].trace[1].x - ObjList[i].trace[0].x;
		dy_1 = ObjList[i].trace[1].y - ObjList[i].trace[0].y;
		r_inv = 1.0/sqrt(dx_1*dx_1 + dy_1*dy_1);
		dx_1 *= r_inv;
		dy_1 *= r_inv;

		dx_2 = ObjList[i].trace[ObjList[i].traj_Pos-1].x - ObjList[i].trace[ObjList[i].traj_Pos-2].x;
		dy_2 = ObjList[i].trace[ObjList[i].traj_Pos-1].y - ObjList[i].trace[ObjList[i].traj_Pos-2].y;
		r_inv = 1.0/sqrt(dx_2*dx_2 + dy_2*dy_2);
		dx_2 *= r_inv;
		dy_2 *= r_inv;

		p_dot = dx_1*dx_2 + dy_1*dy_2;
		p_dot_abs = fabs(p_dot);
		p_cross = dx_1*dy_2 - dx_2*dy_1;

		if( p_dot_abs >  0.707)	{	// < 45 degree or > 135 degree
			if(p_dot > 0)	{	// < 45 degree
				Direction = 0;	// straight
			}
			else	{	// > 135 degree
				Direction = 3;	// U turn
			}
		}
		else	{
			if(p_cross > 0)	{	// left turn
//				Direction = 1;
				Direction = 2;
			}
			else	{	// right turn
//				Direction = 2;
				Direction = 1;
			}
		}

		// car index, x1, y1, x2, y2, p_dot, p_cross, orientation
//		printf("DBG> vector info: %4d (%d,%d) (%d,%d) (%d,%d) (%d,%d)\n", 
//			ObjList[i].Idx, ObjList[i].trace[0].x, ObjList[i].trace[0].y, ObjList[i].trace[1].x, ObjList[i].trace[1].y, 
//			ObjList[i].trace[ObjList[i].traj_Pos-2].x, ObjList[i].trace[ObjList[i].traj_Pos-2].y, ObjList[i].trace[ObjList[i].traj_Pos-1].x, ObjList[i].trace[ObjList[i].traj_Pos-1].y);
		fprintf(fVector, "%4d, %7.4f, %7.4f, %7.4f, %7.4f, %7.4f, %7.4f, %s\n", ObjList[i].Idx, dx_1, dy_1, dx_2, dy_2, p_dot, p_cross, szDirection[Direction]);
	}
}

void Output_Rest_Orientation_Data(void)
{
	int i;

	for(i=0; i<MAX_OBJ; i++)	{
		if(ObjList[i].Confirmed)	{
			Output_Orientation_Data(i);
		}
	}
}

#define DIST_SQ_CUT_SAME_COLOR	(650)
//#define N_PIXLES	(400)
#define N_PIXLES	(2000)
int Pixles[N_PIXLES*3*2];	// list of pixles
int Pixles_bg[N_PIXLES*3*2];	// list of pixles in background

/*
void Find_Dominant_Color(int *data, int n, int &R, int &G, int &B)
{
	int i, j, dist_SQ, dr, dg, db, *count, Pos_i, Pos_j, MaxCount=0, IdxSave;

	count = (int*)malloc(n*sizeof(int));
	memset(count, 0, sizeof(int)*n);

	for(i=0; i<n; i++)	{
		Pos_i = i * 3;
		for(j=i+1; j<n; j++)	{
			Pos_j = j * 3;
			dr = data[Pos_i  ] - data[Pos_j  ];
			dg = data[Pos_i+1] - data[Pos_j+1];
			db = data[Pos_i+2] - data[Pos_j+2];
			dist_SQ = dr*dr + dg*dg + db*db;
			if(dist_SQ < DIST_SQ_CUT_SAME_COLOR)	{
				count[i]++;
				count[j]++;
			}
		}
	}
	for(i=0; i<n; i++)	{
		if(MaxCount < count[i])	{
			MaxCount = count[i];
			IdxSave = i;
		}
	}
	Pos_i = IdxSave * 3;
	R = data[Pos_i  ];
	G = data[Pos_i+1];
	B = data[Pos_i+2];
	
	free(count);
}
*/

void Find_Dominant_Color(int *data, int n, int &R, int &G, int &B, int R_bg, int G_bg, int B_bg, int IsBG)
{
	int i, j, dist_SQ, dr, dg, db, Pos_i, Pos_j, IdxSave, *ToUse, nReal;
	float *count, MaxCount=0.0;

	count = (float*)malloc(n*sizeof(float));
	memset(count, 0, sizeof(float)*n);

	if(IsBG)	{
		for(i=0; i<n; i++)	{
			Pos_i = i * 3;
			for(j=i+1; j<n; j++)	{
				Pos_j = j * 3;
				dr = data[Pos_i  ] - data[Pos_j  ];
				dg = data[Pos_i+1] - data[Pos_j+1];
				db = data[Pos_i+2] - data[Pos_j+2];
				dist_SQ = dr*dr + dg*dg + db*db;
				if(dist_SQ < DIST_SQ_CUT_SAME_COLOR)	{
					count[i]+=1.0;
					count[j]+=1.0;
				}
			}
		}
		for(i=0; i<n; i++)	{
			if(MaxCount < count[i])	{
				MaxCount = count[i];
				IdxSave = i;
			}
		}
		Pos_i = IdxSave * 3;
		R = data[Pos_i  ];
		G = data[Pos_i+1];
		B = data[Pos_i+2];
	}
	else	{
		nReal = 0;
		ToUse = (int*)malloc(n*sizeof(float));
		for(i=0; i<n; i++)	{
			Pos_i = i * 3;
			dr = data[Pos_i  ] - R_bg;
			dg = data[Pos_i+1] - G_bg;
			db = data[Pos_i+2] - B_bg;
			dist_SQ = dr*dr + dg*dg + db*db;
			if(dist_SQ < DIST_SQ_CUT_SAME_COLOR)	{
				ToUse[i] = 0;
			}
			else	{
				ToUse[i] = 1;
				nReal++;
			}
		}

		if(nReal < (int)(N_PIXLES*0.2) )	{
			free(ToUse);
			free(count);

			R = R_bg;
			G = G_bg;
			B = B_bg;

			return;
		}

		for(i=0; i<n; i++)	{
			if(ToUse[i] == 0)	continue;

			Pos_i = i * 3;
			for(j=i+1; j<n; j++)	{
				if(ToUse[j] == 0)	continue;
				
				Pos_j = j * 3;
				dr = data[Pos_i  ] - data[Pos_j  ];
				dg = data[Pos_i+1] - data[Pos_j+1];
				db = data[Pos_i+2] - data[Pos_j+2];
				dist_SQ = dr*dr + dg*dg + db*db;
				if(dist_SQ < DIST_SQ_CUT_SAME_COLOR)	{
					count[i]+=1.0;
					count[j]+=1.0;
				}
			}
		}
		for(i=0; i<n; i++)	{
			if(MaxCount < count[i])	{
				MaxCount = count[i];
				IdxSave = i;
			}
		}
		Pos_i = IdxSave * 3;
		R = data[Pos_i  ];
		G = data[Pos_i+1];
		B = data[Pos_i+2];
		
		free(ToUse);
	}
	
	free(count);
}



#define CUT_DIFF_SQ_FG	(700)
void Find_Car_Pixles(void)	// pick the most dominant color of car within non-overlaped regions
{
	uchar *ptr_frame, *ptr_bg, *ptr_mask, R, G, B, dR, dG, dB, Min, Max;
	int i, x, y, dRGB;
	int step_color, step_gray;
	int idx_color;
	int count, nPixles, Gap, IdxPixle, iPos;
	int R_bg, G_bg, B_bg;
	double R_Sum, G_Sum, B_Sum, R_Avg, G_Avg, B_Avg;
	char szTxt[64];

	if(lt_bg.empty())	return;
//	imwrite("out_bg.jpg", lt_bg);

	step_color = frame.step;
	step_gray = fg.step;

	for(y=0; y<height; y++)        {
		for(x=0; x<width; x++)        {
			ptr_frame = frame_save.data + y*step_color + 3*x;
			ptr_bg = lt_bg.data + y*step_color + 3*x;
			ptr_mask = fg.data + y*step_gray + x;

			dR = ptr_frame[0] - ptr_bg[0];
			dG = ptr_frame[1] - ptr_bg[1];
			dB = ptr_frame[2] - ptr_bg[2];

			dRGB = dR*dR + dG*dG + dB*dB;

			if(dRGB < CUT_DIFF_SQ_FG)	{
				*ptr_mask = 0;
			}
			else	{
				*ptr_mask = 1;
			}
		}
	}

	for(i=0; i<MAX_OBJ; i++)	{
		if(ObjList[i].Confirmed)	{
			for(y=ObjList[i].y; y<=ObjList[i].yMax; y++)	{
				for(x=ObjList[i].x; x<=ObjList[i].xMax; x++)	{
					ptr_mask = fg.data + y*step_gray + x;
					if(*ptr_mask)	*ptr_mask = *ptr_mask + 1;
				}
			}
		}
	}

	// all pixles with *ptr_mask == 2 means the indicative pixles of a single car

	for(i=0; i<MAX_OBJ; i++)	{
		if(ObjList[i].Confirmed)	{
			nPixles = 0;
			for(y=ObjList[i].y; y<=ObjList[i].yMax; y++)	{
				for(x=ObjList[i].x; x<=ObjList[i].xMax; x++)	{
					ptr_mask = fg.data + y*step_gray + x;
					if(*ptr_mask == 2)	nPixles++;
				}
			}
			ObjList[i].nPixles = nPixles;
			printf("Car %d: %d pixles.\n", ObjList[i].Idx, nPixles);
		}
	}
	for(i=0; i<MAX_OBJ; i++)	{
		if(ObjList[i].Confirmed)	{
			IdxPixle = 0;
			count = 0;
			Gap = 1;
			if(ObjList[i].nPixles > N_PIXLES)	{
				Gap = ObjList[i].nPixles/N_PIXLES;
			}
			else 
				continue;
			for(y=ObjList[i].y; y<=ObjList[i].yMax; y++)	{
				for(x=ObjList[i].x; x<=ObjList[i].xMax; x++)	{
					ptr_mask = fg.data + y*step_gray + x;
					if( ( (*ptr_mask) == 2) && (x%Gap == 0) )	{	// pixles of a single car, 	evenly select a small part of pixles
						ptr_frame = frame_save.data + y*step_color + 3*x;
						iPos = 3 * count;
						Pixles[iPos  ] = (int)(ptr_frame[0]);
						Pixles[iPos+1] = (int)(ptr_frame[1]);
						Pixles[iPos+2] = (int)(ptr_frame[2]);
						
						ptr_bg = lt_bg.data + y*step_color + 3*x;
						Pixles_bg[iPos  ] = (int)(ptr_bg[0]);
						Pixles_bg[iPos+1] = (int)(ptr_bg[1]);
						Pixles_bg[iPos+2] = (int)(ptr_bg[2]);
						count++;
					}
				}
			}
			Find_Dominant_Color(Pixles_bg, count, R_bg, G_bg, B_bg, 0, 0, 0, 1);	// find the dominant color of the background
//			Find_Dominant_Color(Pixles, count, ObjList[i].R, ObjList[i].G, ObjList[i].B, R_bg, G_bg, B_bg, 0);	// find the dominant color of the foreground
			Find_Dominant_Color(Pixles, count, ObjList[i].B, ObjList[i].G, ObjList[i].R, R_bg, G_bg, B_bg, 0);	// find the dominant color of the foreground

//			Mat tmp=Mat(frame_save, Rect(ObjList[i].x, ObjList[i].y, ObjList[i].xMax-ObjList[i].x, ObjList[i].yMax-ObjList[i].y));
//			imwrite("tmp.jpg", tmp);

//			Find_Dominant_Color(Pixles, count, ObjList[i].R, ObjList[i].G, ObjList[i].B);
			sprintf(szTxt, "(%d,%d,%d)", ObjList[i].R, ObjList[i].G, ObjList[i].B );
	        putText(frame, szTxt, cv::Point( ObjList[i].x, ObjList[i].y), FONT_HERSHEY_SIMPLEX, 1.0, cv::Scalar(0,0,255));
		}
	}

/*
	for(y=0; y<height; y++)        {
		for(x=0; x<width; x++)        {
			ptr_frame = frame.data + y*step_color + 3*x;
			ptr_mask = fg.data + y*step_gray + x;
			if(*ptr_mask == 2)	{
				ptr_frame[0] = 0;
				ptr_frame[1] = 255;
				ptr_frame[2] = 0;
			}

		}
	}
*/
}


